<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>奇偶數的判別</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* * 數學式樣式 (依據需求設定)
         */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');

        body {
            font-family: 'Noto Sans TC', sans-serif;
            overflow: hidden; /* 防止整頁捲動，改由內部區塊捲動 */
            background-color: #f3f4f6;
        }

        .math {
            font-family: 'Times New Roman', serif;
            font-size: 1.5rem; /* 24px -> 調整為相對單位以便縮放 */
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-style: italic;
        }

        .fraction {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.1;
            font-style: normal;
        }

        .fraction span:first-child {
            border-bottom: 2px solid #000;
            padding: 0 4px;
        }

        .power {
            font-size: 0.7em;
            vertical-align: super;
            margin-left: 2px;
            color: #e63946;
        }

        .sqrt::before {
            content: "√";
            font-size: 1.2em;
            margin-right: 2px;
        }

        .abs::before { content: "|"; }
        .abs::after { content: "|"; }

        .mixed {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }

        /* * 互動元件樣式
         */
        .slot {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 80px;
            height: 48px;
            border: 2px dashed #9ca3af;
            border-radius: 0.5rem;
            background-color: #ffffff;
            margin: 0 4px;
            cursor: pointer;
            font-weight: bold;
            color: #374151;
            transition: all 0.2s;
            vertical-align: middle;
            font-size: 1.125rem;
        }

        .slot.active {
            border-color: #3b82f6;
            background-color: #eff6ff;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .slot.filled {
            border-style: solid;
            border-color: #3b82f6;
            background-color: #fff;
            color: #2563eb;
        }

        .slot.correct {
            border-color: #10b981;
            background-color: #ecfdf5;
            color: #059669;
        }

        .option-btn {
            background-color: #fff;
            border: 2px solid #e5e7eb;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            color: #374151;
            box-shadow: 0 2px 0 #d1d5db;
            transition: all 0.1s;
            font-size: 1.125rem;
        }

        .option-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }

        .option-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #f3f4f6;
            transform: none;
            box-shadow: none;
        }

        /* * 動畫與特效
         */
        @keyframes tada {
            0% { transform: scale(1); }
            10%, 20% { transform: scale(0.9) rotate(-3deg); }
            30%, 50%, 70%, 90% { transform: scale(1.1) rotate(3deg); }
            40%, 60%, 80% { transform: scale(1.1) rotate(-3deg); }
            100% { transform: scale(1) rotate(0); }
        }

        .animate-tada {
            animation: tada 1s;
        }

        .step-card {
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .step-locked {
            opacity: 0.4;
            pointer-events: none;
            filter: grayscale(100%);
        }

        /* * 響應式佈局調整
         */
        #app-container {
            height: calc(100vh - 64px); /* 扣除導覽列高度 */
        }
        
        /* 自定義捲軸 */
        .custom-scroll::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #f1f1f1; 
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #c1c1c1; 
            border-radius: 4px;
        }
        .custom-scroll::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8; 
        }

        mark {
            background-color: #fef08a;
            padding: 0 4px;
            border-radius: 4px;
            font-weight: bold;
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- 頂部導覽列 -->
    <nav class="h-16 bg-indigo-600 text-white shadow-md flex items-center z-50 relative">
        <div class="px-4 font-bold text-lg whitespace-nowrap border-r border-indigo-500 mr-2 flex items-center">
            <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
            奇偶數的判別
        </div>
        <div class="flex-1 overflow-x-auto custom-scroll flex items-center px-2 space-x-3" id="nav-items">
            <!-- 題目按鈕將由 JS 生成 -->
        </div>
    </nav>

    <!-- 主應用區塊 -->
    <div id="app-container" class="flex flex-col md:flex-row relative">
        
        <!-- 左側：題目區 (桌機固定，手機在上方) -->
        <aside class="w-full md:w-1/3 bg-white border-b md:border-b-0 md:border-r border-gray-200 p-6 overflow-y-auto custom-scroll md:sticky md:top-0 h-auto md:h-full shrink-0 z-10 shadow-sm">
            <div id="question-area" class="max-w-2xl mx-auto">
                <!-- 題目內容由 JS 渲染 -->
            </div>
            <!-- 小提示卡片 -->
            <div class="mt-6 bg-blue-50 border-l-4 border-blue-500 p-4 rounded-r text-sm text-blue-800">
                <div class="flex items-start">
                    <svg class="w-5 h-5 mr-2 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <div>
                        <p class="font-bold mb-1">解題小撇步：代入法</p>
                        <p>既然 <span class="math">a</span> 是奇數，你可以試著把 <span class="math">a</span> 當作 <strong class="text-red-500 text-lg">1</strong> 或 <strong class="text-red-500 text-lg">3</strong> 來計算看看喔！</p>
                    </div>
                </div>
            </div>
        </aside>

        <!-- 右側：步驟解鎖區 (桌機捲動，手機在下方) -->
        <main class="w-full md:w-2/3 bg-gray-50 p-4 md:p-8 overflow-y-auto custom-scroll relative h-full" id="steps-container">
            <div class="max-w-3xl mx-auto space-y-6 pb-20" id="steps-list">
                <!-- 步驟卡片由 JS 生成 -->
            </div>
        </main>

    </div>

    <!-- 完成視窗 (Modal) -->
    <div id="completion-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden opacity-0 transition-opacity duration-300">
        <div class="bg-white rounded-2xl p-8 max-w-sm w-full mx-4 shadow-2xl transform scale-90 transition-transform duration-300 text-center">
            <div class="w-20 h-20 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4 text-green-500">
                <svg class="w-12 h-12" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path></svg>
            </div>
            <h2 class="text-2xl font-bold text-gray-800 mb-2">太棒了！全數完成</h2>
            <p class="text-gray-600 mb-6">你已經成功判斷了所有的奇偶性！</p>
            <div class="flex gap-3">
                <button onclick="gameController.retryCurrentProblem()" class="flex-1 px-4 py-3 bg-indigo-100 text-indigo-700 rounded-xl font-bold hover:bg-indigo-200 transition">再做一次</button>
                <button onclick="gameController.closeModal()" class="flex-1 px-4 py-3 bg-gray-200 text-gray-700 rounded-xl font-bold hover:bg-gray-300 transition">關閉視窗</button>
            </div>
        </div>
    </div>

    <!-- 音效 (使用 AudioContext 在 JS 生成，無需外連) -->

    <script>
        // --- 題庫資料結構 ---
        const problemData = [
            {
                id: 1,
                title: "題目 1",
                questionHtml: `
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="bg-indigo-600 text-white text-sm px-2 py-1 rounded mr-2">Q1</span>
                        判別奇偶數
                    </h2>
                    <p class="text-lg leading-relaxed mb-4">
                        已知 <span class="math">a</span> 為<mark>奇數</mark>，請判別下列各個數值為奇數或偶數。
                    </p>
                `,
                steps: [
                    {
                        id: 'p1_s1',
                        instruction: `(1) <span class="math">a + 1</span>`,
                        hint: "想像 a = 1，那麼 1 + 1 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p1_s2',
                        instruction: `(2) <span class="math">a + 5</span>`,
                        hint: "奇數 + 奇數 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p1_s3',
                        instruction: `(3) <span class="math">2a - 4</span>`,
                        hint: "偶數 - 偶數 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p1_s4',
                        instruction: `(4) <span class="math">3a - 5</span>`,
                        hint: "3乘奇數是奇數，奇數 - 奇數 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    }
                ]
            },
            {
                id: 2,
                title: "題目 2",
                questionHtml: `
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="bg-indigo-600 text-white text-sm px-2 py-1 rounded mr-2">Q2</span>
                        判別奇偶數
                    </h2>
                    <p class="text-lg leading-relaxed mb-4">
                        已知 <span class="math">a</span> 為<mark>奇數</mark>，請判別下列各個數值為奇數或偶數。
                    </p>
                `,
                steps: [
                    {
                        id: 'p2_s1',
                        instruction: `(1) <span class="math">a + 3</span>`,
                        hint: "想像 a = 1，那麼 1 + 3 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p2_s2',
                        instruction: `(2) <span class="math">a - 4</span>`,
                        hint: "奇數 - 偶數 = ?",
                        answer: "奇數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p2_s3',
                        instruction: `(3) <span class="math">5a - 4</span>`,
                        hint: "5乘奇數是奇數，奇數 - 偶數 = ?",
                        answer: "奇數",
                        options: ["奇數", "偶數"]
                    },
                    {
                        id: 'p2_s4',
                        instruction: `(4) <span class="math">3a - 5</span>`,
                        hint: "3乘奇數是奇數，奇數 - 奇數 = ?",
                        answer: "偶數",
                        options: ["奇數", "偶數"]
                    }
                ]
            }
        ];

        // --- 音效控制器 ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'correct') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(500, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1000, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'pop') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        // --- 遊戲邏輯控制器 ---
        class GameController {
            constructor() {
                this.currentProblemIdx = 0;
                this.currentStepIdx = 0;
                this.answersState = {}; // 儲存每個 step 的答案 { stepId: "answer" }
                this.isCompleted = false;
                this.init();
            }

            init() {
                this.renderNavbar();
                this.loadProblem(0);
                
                // 鍵盤無障礙支援 (Enter 確認, Esc 清除)
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        // 尋找當前活躍步驟的檢查按鈕
                        const activeBtn = document.querySelector('.step-card:not(.step-locked) .check-btn');
                        if (activeBtn) activeBtn.click();
                    }
                });
            }

            renderNavbar() {
                const navContainer = document.getElementById('nav-items');
                navContainer.innerHTML = '';
                problemData.forEach((prob, idx) => {
                    const btn = document.createElement('button');
                    btn.className = `px-4 py-1 rounded-full text-sm font-bold whitespace-nowrap transition-colors ${
                        idx === this.currentProblemIdx 
                        ? 'bg-white text-indigo-600 shadow-sm' 
                        : 'bg-indigo-500 text-indigo-100 hover:bg-indigo-400'
                    }`;
                    btn.innerText = prob.title;
                    btn.onclick = () => this.switchProblem(idx);
                    navContainer.appendChild(btn);
                });
            }

            switchProblem(idx) {
                if (idx === this.currentProblemIdx) return;
                this.currentProblemIdx = idx;
                this.currentStepIdx = 0; // 切換題目時重置進度？需求說「切換時需保留答題進度」，所以這裡需要讀取狀態
                // 這裡簡化為：切換題目時，若該題未做過則從頭開始，若做過則保留狀態。
                // 由於題目狀態較複雜，我們採用「重新渲染，但依據記憶體中的 answersState 恢復畫面」的策略
                // 但為了簡單起見，本範例切換題目時保留該題目的暫存狀態需要複雜的 State Management。
                // 依照需求 10: "切換時需保留答題進度"。
                // 我們將 currentStepIdx 綁定在 problemData 上比較好。
                if (problemData[idx].savedStepIdx === undefined) {
                    problemData[idx].savedStepIdx = 0;
                }
                this.currentStepIdx = problemData[idx].savedStepIdx;
                
                this.renderNavbar();
                this.loadProblem(idx);
            }

            loadProblem(idx) {
                const problem = problemData[idx];
                
                // 1. 渲染左側題目
                document.getElementById('question-area').innerHTML = problem.questionHtml;

                // 2. 渲染右側步驟
                const stepsContainer = document.getElementById('steps-list');
                stepsContainer.innerHTML = '';

                problem.steps.forEach((step, stepIndex) => {
                    const stepEl = this.createStepElement(step, stepIndex);
                    stepsContainer.appendChild(stepEl);
                });

                // 3. 恢復進度狀態
                // 將已完成的步驟設為 completed
                // 將當前步驟設為 active
                this.updateStepsVisibility();
            }

            createStepElement(stepData, stepIndex) {
                // 檢查是否已回答
                const savedAnswer = this.answersState[stepData.id] || "";
                const isCorrect = savedAnswer === stepData.answer;

                const card = document.createElement('div');
                card.id = `step-${stepIndex}`;
                card.className = `step-card bg-white rounded-xl shadow-sm border border-gray-200 p-5 mb-4 relative overflow-hidden ${stepIndex > this.currentStepIdx ? 'step-locked' : ''}`;
                
                // 完成標記
                const doneBadge = `<span class="completed-badge absolute top-4 right-4 text-green-500 font-bold flex items-center ${isCorrect ? '' : 'hidden'}">
                    <svg class="w-6 h-6 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                    完成
                </span>`;

                // HTML 結構
                card.innerHTML = `
                    ${doneBadge}
                    <div class="flex items-center mb-4">
                        <div class="w-8 h-8 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold mr-3 text-sm">
                            ${stepIndex + 1}
                        </div>
                        <div class="text-xl font-medium text-gray-800 flex items-center flex-wrap">
                            ${stepData.instruction}
                            <span class="mx-2 text-gray-400">→</span>
                            <div class="slot ${isCorrect ? 'filled correct' : ''}" id="slot-${stepData.id}" onclick="gameController.clearSlot('${stepData.id}')">
                                ${savedAnswer}
                            </div>
                        </div>
                    </div>
                    
                    <div class="pl-11">
                        <p class="text-sm text-gray-500 mb-3 italic flex items-center">
                            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                            ${stepData.hint}
                        </p>
                        
                        <div class="options-area flex flex-wrap gap-2 mb-4 ${isCorrect ? 'hidden' : ''}">
                            ${stepData.options.map(opt => `
                                <button class="option-btn hover:bg-indigo-50 hover:border-indigo-200" 
                                    onclick="gameController.fillSlot('${stepData.id}', '${opt}', this)"
                                    data-val="${opt}">
                                    ${opt}
                                </button>
                            `).join('')}
                        </div>

                        <div class="feedback-area flex items-center justify-between h-10">
                             <div class="feedback-msg text-red-500 font-bold hidden flex items-center">
                                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                再想想看
                             </div>
                             <button class="check-btn bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-2 rounded-lg font-bold shadow-lg transform active:scale-95 transition-all ${isCorrect ? 'hidden' : ''}" 
                                onclick="gameController.checkStep(${stepIndex})">
                                檢查答案
                             </button>
                        </div>
                    </div>
                `;

                // 恢復按鈕狀態 (如果 slot 已經被填了但還沒檢查正確，需要禁用該按鈕)
                if (savedAnswer && !isCorrect) {
                     const btn = card.querySelector(`.option-btn[data-val="${savedAnswer}"]`);
                     if(btn) btn.disabled = true;
                }

                return card;
            }

            fillSlot(stepId, value, btnEl) {
                const slot = document.getElementById(`slot-${stepId}`);
                if (slot.classList.contains('filled')) return; // 已經有值

                playSound('pop');
                slot.innerText = value;
                slot.classList.add('active'); // 視覺反饋
                this.answersState[stepId] = value;
                
                // 禁用按鈕
                btnEl.disabled = true;

                // 隱藏錯誤訊息（如果有）
                const card = btnEl.closest('.step-card');
                card.querySelector('.feedback-msg').classList.add('hidden');
            }

            clearSlot(stepId) {
                const slot = document.getElementById(`slot-${stepId}`);
                // 如果已經 Correct (綠色) 則不能清除 (題目要求步驟完成保持可見，通常不建議清除正確答案，除非重置)
                if (slot.classList.contains('correct')) return;
                
                const currentVal = slot.innerText;
                if (!currentVal) return;

                playSound('pop');
                slot.innerText = '';
                slot.classList.remove('active');
                this.answersState[stepId] = "";

                // 恢復按鈕
                const card = slot.closest('.step-card');
                const btn = card.querySelector(`.option-btn[data-val="${currentVal}"]`);
                if (btn) btn.disabled = false;
            }

            checkStep(stepIndex) {
                const problem = problemData[this.currentProblemIdx];
                const stepData = problem.steps[stepIndex];
                const stepId = stepData.id;
                const slot = document.getElementById(`slot-${stepId}`);
                const userVal = slot.innerText.trim();
                const card = slot.closest('.step-card');
                const feedbackMsg = card.querySelector('.feedback-msg');

                if (!userVal) {
                    feedbackMsg.innerText = "請填入答案";
                    feedbackMsg.classList.remove('hidden');
                    playSound('wrong');
                    return;
                }

                if (userVal === stepData.answer) {
                    // 正確
                    playSound('correct');
                    slot.classList.remove('active');
                    slot.classList.add('filled', 'correct', 'animate-tada');
                    
                    // UI 更新
                    card.querySelector('.completed-badge').classList.remove('hidden');
                    card.querySelector('.options-area').classList.add('hidden');
                    card.querySelector('.check-btn').classList.add('hidden');
                    feedbackMsg.classList.add('hidden');

                    // 解鎖下一步
                    this.unlockNext(stepIndex);
                } else {
                    // 錯誤
                    playSound('wrong');
                    feedbackMsg.innerHTML = `<svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg> 再想想看`;
                    feedbackMsg.classList.remove('hidden');
                    // 不清除 slot，也不恢復按鈕，讓學生看著錯誤答案思考
                }
            }

            unlockNext(currentStepIndex) {
                const problem = problemData[this.currentProblemIdx];
                
                // 儲存進度
                problem.savedStepIdx = currentStepIndex + 1;
                this.currentStepIdx = currentStepIndex + 1;

                if (this.currentStepIdx < problem.steps.length) {
                    // 還有下一步
                    const nextCard = document.getElementById(`step-${this.currentStepIdx}`);
                    nextCard.classList.remove('step-locked');
                    
                    // 平滑捲動
                    setTimeout(() => {
                        nextCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                } else {
                    // 全部完成
                    this.showCompletion();
                }
            }

            updateStepsVisibility() {
                // 根據 currentStepIdx 設定鎖定狀態
                const cards = document.querySelectorAll('.step-card');
                cards.forEach((card, idx) => {
                    if (idx > this.currentStepIdx) {
                        card.classList.add('step-locked');
                    } else {
                        card.classList.remove('step-locked');
                    }
                });
                
                // 如果已經做到一半，捲動到最新步驟
                if (this.currentStepIdx > 0 && this.currentStepIdx < problemData[this.currentProblemIdx].steps.length) {
                    setTimeout(() => {
                         const currentCard = document.getElementById(`step-${this.currentStepIdx}`);
                         if(currentCard) currentCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            }

            showCompletion() {
                const modal = document.getElementById('completion-modal');
                modal.classList.remove('hidden');
                // 稍微延遲讓 display: block 生效後再加 opacity 動畫
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    modal.querySelector('div').classList.remove('scale-90');
                    modal.querySelector('div').classList.add('scale-100');
                    playSound('correct'); // 完成音效
                }, 50);
            }

            closeModal() {
                const modal = document.getElementById('completion-modal');
                modal.classList.add('opacity-0');
                modal.querySelector('div').classList.remove('scale-100');
                modal.querySelector('div').classList.add('scale-90');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            }

            retryCurrentProblem() {
                this.closeModal();
                const problem = problemData[this.currentProblemIdx];
                
                // 清除該題所有答案
                problem.steps.forEach(step => {
                    delete this.answersState[step.id];
                });
                
                // 重置進度
                problem.savedStepIdx = 0;
                this.currentStepIdx = 0;
                
                // 重新渲染
                this.loadProblem(this.currentProblemIdx);
                
                // 捲回頂部
                document.getElementById('steps-container').scrollTop = 0;
            }
        }

        // 初始化
        const gameController = new GameController();

    </script>
</body>
</html>